<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Dijkstra Demonstrator</title>

  <style>
    svg { user-select: none; }
    svg text::selection {
      background: none;
      color: initial;
    }

    .clear { clear: both; }

    .dijkstra-demonstrator { background: #4e4e4e; color: #fff; font-family: sans-serif; padding: 25px; border-radius: 15px; }
    .dijkstra-table { background: #fff; padding: 20px; border-radius: 10px; }
    .dijkstra-table td { width: 40px; text-align: center; }
    .dijkstra-table .step { width: 70px; }
    .map { float: left; margin-right: 50px; }
    .map-legal { font-size: 8pt; text-align: center; }
    .map-legal a { color: #fff; }

    .svg-edge text { font-size: 9pt; }
    .svg-vertex { cursor: pointer; }
    .svg-vertex circle { fill: white; transition: fill 0.5s; }
    .svg-vertex:hover circle { fill: orange; transition: fill 0.1s; }
    .svg-vertex text { font-size: 11pt; }
  </style>
</head>

<body>
  <script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"></script>
  <script src="scripts/common.js"></script>
  <script src="scripts/graph-viewer.js"></script>
  <script src="scripts/lhs-graph.js"></script>

  <script type="text/x-template" id="dijkstra-table-row">
    <tr>
      <td class="step">Schritt {{ step }}</td>
      <td v-for="value, key in distances">
        <span v-if="isFinite(value.distance)">{{ value.distance }}<span v-if="value.previous != null"> via {{ value.previous }}</span></span>
        <span v-else>&#8734;</span>
      </td>
    </tr>
  </script>

  <div class="dijkstra-demonstrator" id="app">
    <div class="map">
      <svg viewBox="0 30 400 540" width="530" height="700">
        <image width="400" height="600" xlink:href="maps/vk2500-l-fg/vk2500-l-fg.png" />
        <svg-graph :graph="graph" :click-handler="vertex_clicked"></svg-graph>
      </svg>
      <div class="map-legal">
        Grafisch freigestellter Kartenauszug | © GeoBasis-DE / <a href="http://www.bkg.bund.de" target="blank">BKG</a> 2018 (Daten verändert)
      </div>
    </div>
    <div class="controls">
      <table class="dijkstra-table" v-if="dijkstra_status != null">
        <thead>
          <tr>
            <th></th>
            <th v-for="key in vertex_keys">{{ key }}</th>
          </tr>
        </thead>
        <tbody>
          <template>
            <dijkstra-table-row v-for="distances, index in dijkstra_status.history" :distances="distances" :step="index"></dijkstra-table-row>
            <dijkstra-table-row :distances="dijkstra_status.distances" :step="dijkstra_status.history.length + 1"></dijkstra-table-row>
          </template>
        </tbody>
      </table>
    </div>
    <div class="clear"></div>
  </div>

  <script type="text/javascript">
    async function init() {
      await init_graph_viewer();

      Vue.component('dijkstra-table-row', {
        template: '#dijkstra-table-row',
        props: ["distances", "step"]
      })

      var app = new Vue({
        el: '#app',
        data() { return {
          dijkstra_status: null,
          graph: lhs_graph()
        } },
        computed: {
          vertex_keys() {
            var result = []
            for (var key in this.graph.vertices) {
              if (this.graph.vertices.hasOwnProperty(key))
                result.push(key)
            }
            return result
          }
        },
        methods: {
          build_dijkstra_status(start_vertex) {
            var status = {
              visited: [],
              distances: {},
              history: [],
              start_vertex: start_vertex
            }

            for (var i = 0; i < this.vertex_keys.length; i++) {
              var key = this.vertex_keys[i]
              status.distances[key] = {
                distance: (key == start_vertex) ? 0 : Infinity,
                previous: null
              }
            }

            return status
          },
          dijkstra() {
            // Find closest vertex
            var closestVertex = null
            var closestDistance = Infinity
            for (var i = 0; i < this.vertex_keys.length; i++) {
              var key = this.vertex_keys[i]

              if (this.dijkstra_status.visited.includes(key)) // Refactor into function. also below.
                continue;

              var distance = this.dijkstra_status.distances[key]

              if (distance.distance < closestDistance) {
                closestVertex = key
                closestDistance = distance.distance
              }
            }

            if (closestDistance == Infinity)
              return;

            // Push current distances into history
            this.dijkstra_status.history.push(this.dijkstra_status.distances)
            this.dijkstra_status.distances = Object.assign({}, this.dijkstra_status.distances)

            // Mark current vertex as visited
            this.dijkstra_status.visited.push(closestVertex)

            // Look at outgoing edges
            var outgoing = this.outgoing_edges(closestVertex)
            for (var i = 0; i < outgoing.length; i++) {
              var edge = outgoing[i]
              if (this.dijkstra_status.visited.includes(edge.to))
                continue;

              var newDistance = closestDistance + edge.weight
              if (newDistance < this.dijkstra_status.distances[edge.to].distance) {
                this.dijkstra_status.distances[edge.to] = {
                  distance: newDistance,
                  previous: (closestVertex == this.dijkstra_status.start_vertex) ? null : closestVertex
                }
              }
            }

            this.dijkstra()
          },
          init_dijkstra(start_vertex) {
            this.dijkstra_status = this.build_dijkstra_status(start_vertex)
          },
          outgoing_edges(vertex) {
            var outgoing = []

            for (var i = 0; i < this.graph.edges.length; i++) {
              var edge = this.graph.edges[i]
              if (edge.from == vertex)
                outgoing.push(edge)
            }

            if (this.graph.directed == false) {
              for (var i = 0; i < this.graph.edges.length; i++) {
                var edge = this.graph.edges[i]
                if (edge.to == vertex) {
                  var reversed = Object.assign({}, edge)
                  reversed.to = edge.from
                  reversed.from = edge.to
                  outgoing.push(reversed)
                }
              }
            }

            return outgoing
          },
          vertex_clicked(vertex) {
            this.init_dijkstra(vertex)
            this.dijkstra()
          }
        }
      })
    }

    init()
  </script>

</body>
</html>
